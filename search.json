[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shinylive applications embedded in Quarto documents",
    "section": "",
    "text": "Coordenadas de annulus original: (220, 77) Coordenadas de annulus Reversa: (130, 169)\n#| standalone: true\n#| viewerHeight: 600\nlibrary(shiny)\nlibrary(janitor)  # For clean_names\nlibrary(dplyr)    # For data manipulation\nlibrary(car)      # For the ellipse function\n\n# Define UI for app to upload and analyze CSV file\nui &lt;- fluidPage(\n  titlePanel(\"C치lculo de entrop칤a\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Select a CSV file\n      fileInput(\"file1\", \"Subir coordenadas\", accept = \".csv\"),\n      \n      # Numeric input for defining plat_x and plat_y\n      numericInput(\"plat_x\", \"Coordenadas de plataforma en X\", value = 220),  # Default value set to 220\n      numericInput(\"plat_y\", \"Coordenadas de plataforma en Y\", value = 77),   # Default value set to 77\n      \n      tags$hr(),\n      \n      # Button to calculate entropy\n      actionButton(\"calc_entropy\", \"Calcular\")\n    ),\n    mainPanel(\n      tableOutput(\"entropy_table\"),\n      plotOutput(\"plot\")  # Output plot\n    )\n  )\n)\n\n# Define server logic\nserver &lt;- function(input, output) {\n  observeEvent(input$calc_entropy, {\n    req(input$file1)  # Ensure that a file is uploaded before proceeding\n    \n    # Read the CSV file\n    data &lt;- read.csv(input$file1$datapath)\n    # Clean column names with janitor to ensure consistency\n    data &lt;- janitor::clean_names(data)\n    # Rename the first three columns to 'time', 'X', 'Y'\n    names(data)[1:3] &lt;- c(\"time\", \"X\", \"Y\")\n    \n    # Use input values for plat_x and plat_y\n    plat_x &lt;- input$plat_x\n    plat_y &lt;- input$plat_y\n\n    Xraw &lt;- as.numeric(data$X)\n    Yraw &lt;- as.numeric(data$Y)\n\n    d_x &lt;- Xraw - plat_x\n    d_y &lt;- Yraw - plat_y\n\n    dist2 &lt;- d_x^2 + d_y^2\n\n    w &lt;- 1\n    sw &lt;- sum(w)\n\n    xm &lt;- mean(w * d_x) / sw\n    ym &lt;- mean(w * d_y) / sw\n    xxm &lt;- mean(w * d_x * d_x) / sw\n    yym &lt;- mean(w * d_y * d_y) / sw\n    xym &lt;- mean(w * d_x * d_y) / sw\n\n    Sig &lt;- matrix(c(xxm - xm^2, xym - xm * ym,\n                    xym - xm * ym, yym - ym^2), nrow=2)\n\n    eig_val &lt;- eigen(Sig)$values\n    var_xy2 &lt;- eig_val[1] * eig_val[2]\n\n    mdist2 &lt;- mean(w * dist2) / sw\n\n    entropy &lt;- log(mdist2) + 0.5 * log(var_xy2)\n\n    # Create a data frame for output\n    entropy_data &lt;- data.frame(Entropia = entropy)\n\n    # Output the data frame\n    output$entropy_table &lt;- renderTable({\n      entropy_data\n    })\n\n    # Output the plot\n    output$plot &lt;- renderPlot({\n      # Define limits with a buffer\n      x_lim_buffer &lt;- 100\n      y_lim_buffer &lt;- 100\n      plot(Xraw, Yraw, xlim=c(min(Xraw) - x_lim_buffer, max(Xraw) + x_lim_buffer), ylim=c(min(Yraw) - y_lim_buffer, max(Yraw) + y_lim_buffer), xlab=\"X\", ylab=\"Y\", main=\"Coordenadas del rat칩n alrededor del annulus blanco\")\n      points(plat_x, plat_y, col=\"red\", pch=19)  # Reference point\n      segments(Xraw, Yraw, plat_x, plat_y, col=\"grey\")\n      text(plat_x, plat_y, labels=\"Annulus\", pos=4, col=\"red\")\n\n      # Draw error ellipse and principal axes\n      data_points &lt;- data.frame(Xraw, Yraw)\n      ellipse_center &lt;- c(plat_x, plat_y)\n      cov_matrix &lt;- cov(data_points)\n\n      eig &lt;- eigen(cov_matrix)\n      eig_vec &lt;- eig$vectors\n      eig_val &lt;- eig$values\n\n      # Scale eigenvectors for plotting\n      scale_factor &lt;- 2\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,1] * sqrt(eig_val[1]), plat_y + scale_factor * eig_vec[2,1] * sqrt(eig_val[1]), col=\"purple\")\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,2] * sqrt(eig_val[2]), plat_y + scale_factor * eig_vec[2,2] * sqrt(eig_val[2]), col=\"purple\")\n    })\n  })\n}\n\n\n# Create Shiny app\nshinyApp(ui, server)"
  },
  {
    "objectID": "index.html#c치lculo",
    "href": "index.html#c치lculo",
    "title": "Shinylive applications embedded in Quarto documents",
    "section": "",
    "text": "Coordenadas de annulus original: (220, 77) Coordenadas de annulus Reversa: (130, 169)\n#| standalone: true\n#| viewerHeight: 600\nlibrary(shiny)\nlibrary(janitor)  # For clean_names\nlibrary(dplyr)    # For data manipulation\nlibrary(car)      # For the ellipse function\n\n# Define UI for app to upload and analyze CSV file\nui &lt;- fluidPage(\n  titlePanel(\"C치lculo de entrop칤a\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Select a CSV file\n      fileInput(\"file1\", \"Subir coordenadas\", accept = \".csv\"),\n      \n      # Numeric input for defining plat_x and plat_y\n      numericInput(\"plat_x\", \"Coordenadas de plataforma en X\", value = 220),  # Default value set to 220\n      numericInput(\"plat_y\", \"Coordenadas de plataforma en Y\", value = 77),   # Default value set to 77\n      \n      tags$hr(),\n      \n      # Button to calculate entropy\n      actionButton(\"calc_entropy\", \"Calcular\")\n    ),\n    mainPanel(\n      tableOutput(\"entropy_table\"),\n      plotOutput(\"plot\")  # Output plot\n    )\n  )\n)\n\n# Define server logic\nserver &lt;- function(input, output) {\n  observeEvent(input$calc_entropy, {\n    req(input$file1)  # Ensure that a file is uploaded before proceeding\n    \n    # Read the CSV file\n    data &lt;- read.csv(input$file1$datapath)\n    # Clean column names with janitor to ensure consistency\n    data &lt;- janitor::clean_names(data)\n    # Rename the first three columns to 'time', 'X', 'Y'\n    names(data)[1:3] &lt;- c(\"time\", \"X\", \"Y\")\n    \n    # Use input values for plat_x and plat_y\n    plat_x &lt;- input$plat_x\n    plat_y &lt;- input$plat_y\n\n    Xraw &lt;- as.numeric(data$X)\n    Yraw &lt;- as.numeric(data$Y)\n\n    d_x &lt;- Xraw - plat_x\n    d_y &lt;- Yraw - plat_y\n\n    dist2 &lt;- d_x^2 + d_y^2\n\n    w &lt;- 1\n    sw &lt;- sum(w)\n\n    xm &lt;- mean(w * d_x) / sw\n    ym &lt;- mean(w * d_y) / sw\n    xxm &lt;- mean(w * d_x * d_x) / sw\n    yym &lt;- mean(w * d_y * d_y) / sw\n    xym &lt;- mean(w * d_x * d_y) / sw\n\n    Sig &lt;- matrix(c(xxm - xm^2, xym - xm * ym,\n                    xym - xm * ym, yym - ym^2), nrow=2)\n\n    eig_val &lt;- eigen(Sig)$values\n    var_xy2 &lt;- eig_val[1] * eig_val[2]\n\n    mdist2 &lt;- mean(w * dist2) / sw\n\n    entropy &lt;- log(mdist2) + 0.5 * log(var_xy2)\n\n    # Create a data frame for output\n    entropy_data &lt;- data.frame(Entropia = entropy)\n\n    # Output the data frame\n    output$entropy_table &lt;- renderTable({\n      entropy_data\n    })\n\n    # Output the plot\n    output$plot &lt;- renderPlot({\n      # Define limits with a buffer\n      x_lim_buffer &lt;- 100\n      y_lim_buffer &lt;- 100\n      plot(Xraw, Yraw, xlim=c(min(Xraw) - x_lim_buffer, max(Xraw) + x_lim_buffer), ylim=c(min(Yraw) - y_lim_buffer, max(Yraw) + y_lim_buffer), xlab=\"X\", ylab=\"Y\", main=\"Coordenadas del rat칩n alrededor del annulus blanco\")\n      points(plat_x, plat_y, col=\"red\", pch=19)  # Reference point\n      segments(Xraw, Yraw, plat_x, plat_y, col=\"grey\")\n      text(plat_x, plat_y, labels=\"Annulus\", pos=4, col=\"red\")\n\n      # Draw error ellipse and principal axes\n      data_points &lt;- data.frame(Xraw, Yraw)\n      ellipse_center &lt;- c(plat_x, plat_y)\n      cov_matrix &lt;- cov(data_points)\n\n      eig &lt;- eigen(cov_matrix)\n      eig_vec &lt;- eig$vectors\n      eig_val &lt;- eig$values\n\n      # Scale eigenvectors for plotting\n      scale_factor &lt;- 2\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,1] * sqrt(eig_val[1]), plat_y + scale_factor * eig_vec[2,1] * sqrt(eig_val[1]), col=\"purple\")\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,2] * sqrt(eig_val[2]), plat_y + scale_factor * eig_vec[2,2] * sqrt(eig_val[2]), col=\"purple\")\n    })\n  })\n}\n\n\n# Create Shiny app\nshinyApp(ui, server)"
  },
  {
    "objectID": "index.html#explicaci칩n",
    "href": "index.html#explicaci칩n",
    "title": "Shinylive applications embedded in Quarto documents",
    "section": "Explicaci칩n",
    "text": "Explicaci칩n\nEl c치lculo de entrop칤a est치 basado en la propuesta de Maei et al., 2009.\nPrimero se obtienen de las distancias que se compone de las coordenadas del animal, las diferencias del animal al punto de referencia (annulus blanco), el cuadrado de la distancia Euclidiana, la distancia Euclidiana y el promedia de la distancia (\\(픢_d\\)). Con estos par치metros, se calcula la distancia del animal a la plataforma en cada tiempo utilizando la distancia Euclidiana tomando en cuenta las coordenadas del animal y de la plataforma planco.\n\\[\nd = \\sqrt{(x_a - x_b) + (y_a - y_b)^2}\n\\]\nLas medias ponderadas y la matriz de varianza-covarianza se obtuvo con el siguiente c칩digo, donde la matriz de covarianza se construye con las medias ponderadas y la matriz de covarianza de valores Eigen se calcula para obtener la varianza \\(픢_a^2\\) y \\(洧랥_b^2\\). Con estos par치metros vamos a calcular la varianza de los vectores de las distancias del animal respecto a la plataforma.\nLa matriz de covarianza se utiliza para capturar la vraianza y covarianza de los datos en m치s de una dimensi칩n. Para el caso de dos dimensiones (coordenadas X y Y), la matriz de covarianza se representa como:\n\\[\n풖=\\begin{pmatrix}\nVar(x) & Cov(x,y)\\\\\nCov(x,y) & Var(y)\n\\end{pmatrix}\n\\]\ndonde Var(x) representa la varianza de las coordenadas X, Var(y) representa la varianza de las coordenadas Y, y Cov(x,y) representa la covarianza entre las coordenadas de X y Y. Esta matriz de covarianza resume c칩mo las coordenadas var칤an entre ellas. Si las coordenadas X y Y est치n altamente correlacionadas, la covarianza ser치 alta, indicando una relaci칩n linear alta.\nLos ejes principales o valores Eigen son las direcciones en las que los datos var칤an m치s. Estos ejes se encuentran realizando una descomposici칩n en valores propios de la matriz de covarianza. Los valores propios y los vectores propios obtenidos de esta descomposici칩n tienen las siguientes intepretaciones:\n\nValores Propios: Representan la magnitud de la varianza a lo largo de los ejes principales.\nVectores Propios: Indican la direcci칩n de estos ejes principales.\n\nEstos ejes pueden considerarse como los ejes mayor y menor de una elipse de error que mejor se ajusta a los datos. Ahora, se tiene que sumar los Logaritmos de las varianzas utilizando en el c치lculo de la entrop칤a para cuantificar la dispersi칩n o el desorden de los datos en el plano, reflejando el producto de las varianzas a lo largo de los ejes principales\nPara calcular la media de la distancia al cuadrado y calcular la entrop칤a, se calcula la media de la distancia al cuadrado (\\(픢_2^d\\)). El c치lculo final de entrop칤a se obtiene sumando los logaritmos de las medias cuadradas de la distancia y el producto de los valores Eigen. En resumen, calculamos \\(H_{error}\\) basados en la f칩rmula \\(H_{error} = log(varianza_{distancia})\\), calculamos la varianza de la trayectoria, calculamos la entrop칤a de la trayectoria, realizamos la operaci칩n \\(H_{trayectoria} = log(var_{trayectoria})\\) y finalmente calculamos la entrop칤a total como \\(H_{total} = H_{error} + H_{trayectoria}\\)"
  }
]